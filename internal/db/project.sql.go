// Code generated by sqlc. DO NOT EDIT.
// source: project.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createPersonalProject = `-- name: CreatePersonalProject :one
INSERT INTO project(team_id, created_at, name) VALUES (null, $1, $2) RETURNING project_id, team_id, created_at, name, public_on, short_id
`

type CreatePersonalProjectParams struct {
	CreatedAt time.Time `json:"created_at"`
	Name      string    `json:"name"`
}

func (q *Queries) CreatePersonalProject(ctx context.Context, arg CreatePersonalProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createPersonalProject, arg.CreatedAt, arg.Name)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.PublicOn,
		&i.ShortID,
	)
	return i, err
}

const createPersonalProjectLink = `-- name: CreatePersonalProjectLink :one
INSERT INTO personal_project (project_id, user_id) VALUES ($1, $2) RETURNING personal_project_id, project_id, user_id
`

type CreatePersonalProjectLinkParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) CreatePersonalProjectLink(ctx context.Context, arg CreatePersonalProjectLinkParams) (PersonalProject, error) {
	row := q.db.QueryRowContext(ctx, createPersonalProjectLink, arg.ProjectID, arg.UserID)
	var i PersonalProject
	err := row.Scan(&i.PersonalProjectID, &i.ProjectID, &i.UserID)
	return i, err
}

const createProjectMember = `-- name: CreateProjectMember :one
INSERT INTO project_member (project_id, user_id, role_code, added_at) VALUES ($1, $2, $3, $4)
  RETURNING project_member_id, project_id, user_id, added_at, role_code
`

type CreateProjectMemberParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
	RoleCode  string    `json:"role_code"`
	AddedAt   time.Time `json:"added_at"`
}

func (q *Queries) CreateProjectMember(ctx context.Context, arg CreateProjectMemberParams) (ProjectMember, error) {
	row := q.db.QueryRowContext(ctx, createProjectMember,
		arg.ProjectID,
		arg.UserID,
		arg.RoleCode,
		arg.AddedAt,
	)
	var i ProjectMember
	err := row.Scan(
		&i.ProjectMemberID,
		&i.ProjectID,
		&i.UserID,
		&i.AddedAt,
		&i.RoleCode,
	)
	return i, err
}

const createTeamProject = `-- name: CreateTeamProject :one
INSERT INTO project(team_id, created_at, name) VALUES ($1, $2, $3) RETURNING project_id, team_id, created_at, name, public_on, short_id
`

type CreateTeamProjectParams struct {
	TeamID    uuid.UUID `json:"team_id"`
	CreatedAt time.Time `json:"created_at"`
	Name      string    `json:"name"`
}

func (q *Queries) CreateTeamProject(ctx context.Context, arg CreateTeamProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createTeamProject, arg.TeamID, arg.CreatedAt, arg.Name)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.PublicOn,
		&i.ShortID,
	)
	return i, err
}

const deleteInvitedProjectMemberByID = `-- name: DeleteInvitedProjectMemberByID :exec
DELETE FROM project_member_invited WHERE project_member_invited_id = $1
`

func (q *Queries) DeleteInvitedProjectMemberByID(ctx context.Context, projectMemberInvitedID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteInvitedProjectMemberByID, projectMemberInvitedID)
	return err
}

const deleteProjectByID = `-- name: DeleteProjectByID :exec
DELETE FROM project WHERE project_id = $1
`

func (q *Queries) DeleteProjectByID(ctx context.Context, projectID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProjectByID, projectID)
	return err
}

const deleteProjectMember = `-- name: DeleteProjectMember :exec
DELETE FROM project_member WHERE user_id = $1 AND project_id = $2
`

type DeleteProjectMemberParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) DeleteProjectMember(ctx context.Context, arg DeleteProjectMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectMember, arg.UserID, arg.ProjectID)
	return err
}

const getAllProjectsForTeam = `-- name: GetAllProjectsForTeam :many
SELECT project_id, team_id, created_at, name, public_on, short_id FROM project WHERE team_id = $1
`

func (q *Queries) GetAllProjectsForTeam(ctx context.Context, teamID uuid.UUID) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getAllProjectsForTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.PublicOn,
			&i.ShortID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTeamProjects = `-- name: GetAllTeamProjects :many
SELECT project_id, team_id, created_at, name, public_on, short_id FROM project WHERE team_id IS NOT null
`

func (q *Queries) GetAllTeamProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getAllTeamProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.PublicOn,
			&i.ShortID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVisibleProjectsForUserID = `-- name: GetAllVisibleProjectsForUserID :many
SELECT project.project_id, project.team_id, project.created_at, project.name, project.public_on, project.short_id FROM project LEFT JOIN
 project_member ON project_member.project_id = project.project_id WHERE project_member.user_id = $1
`

func (q *Queries) GetAllVisibleProjectsForUserID(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getAllVisibleProjectsForUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.PublicOn,
			&i.ShortID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitedMembersForProjectID = `-- name: GetInvitedMembersForProjectID :many
SELECT uai.user_account_invited_id, email, invited_on FROM project_member_invited AS pmi
     INNER JOIN user_account_invited AS uai
    ON uai.user_account_invited_id = pmi.user_account_invited_id
     WHERE project_id = $1
`

type GetInvitedMembersForProjectIDRow struct {
	UserAccountInvitedID uuid.UUID `json:"user_account_invited_id"`
	Email                string    `json:"email"`
	InvitedOn            time.Time `json:"invited_on"`
}

func (q *Queries) GetInvitedMembersForProjectID(ctx context.Context, projectID uuid.UUID) ([]GetInvitedMembersForProjectIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitedMembersForProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvitedMembersForProjectIDRow
	for rows.Next() {
		var i GetInvitedMembersForProjectIDRow
		if err := rows.Scan(&i.UserAccountInvitedID, &i.Email, &i.InvitedOn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberProjectIDsForUserID = `-- name: GetMemberProjectIDsForUserID :many
SELECT project_id FROM project_member WHERE user_id = $1
`

func (q *Queries) GetMemberProjectIDsForUserID(ctx context.Context, userID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getMemberProjectIDsForUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var project_id uuid.UUID
		if err := rows.Scan(&project_id); err != nil {
			return nil, err
		}
		items = append(items, project_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonalProjectsForUserID = `-- name: GetPersonalProjectsForUserID :many
SELECT project.project_id, project.team_id, project.created_at, project.name, project.public_on, project.short_id FROM project
  LEFT JOIN personal_project ON personal_project.project_id = project.project_id
  WHERE personal_project.user_id = $1
`

func (q *Queries) GetPersonalProjectsForUserID(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getPersonalProjectsForUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.PublicOn,
			&i.ShortID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT project_id, team_id, created_at, name, public_on, short_id FROM project WHERE project_id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, projectID uuid.UUID) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, projectID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.PublicOn,
		&i.ShortID,
	)
	return i, err
}

const getProjectIDByShortID = `-- name: GetProjectIDByShortID :one
SELECT project_id FROM project WHERE short_id = $1
`

func (q *Queries) GetProjectIDByShortID(ctx context.Context, shortID string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getProjectIDByShortID, shortID)
	var project_id uuid.UUID
	err := row.Scan(&project_id)
	return project_id, err
}

const getProjectMemberInvitedIDByEmail = `-- name: GetProjectMemberInvitedIDByEmail :one
SELECT email, invited_on, project_member_invited_id FROM user_account_invited AS uai
 inner join project_member_invited AS pmi
  ON pmi.user_account_invited_id = uai.user_account_invited_id
  WHERE email = $1
`

type GetProjectMemberInvitedIDByEmailRow struct {
	Email                  string    `json:"email"`
	InvitedOn              time.Time `json:"invited_on"`
	ProjectMemberInvitedID uuid.UUID `json:"project_member_invited_id"`
}

func (q *Queries) GetProjectMemberInvitedIDByEmail(ctx context.Context, email string) (GetProjectMemberInvitedIDByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectMemberInvitedIDByEmail, email)
	var i GetProjectMemberInvitedIDByEmailRow
	err := row.Scan(&i.Email, &i.InvitedOn, &i.ProjectMemberInvitedID)
	return i, err
}

const getProjectMembersForProjectID = `-- name: GetProjectMembersForProjectID :many
SELECT project_member_id, project_id, user_id, added_at, role_code FROM project_member WHERE project_id = $1
`

func (q *Queries) GetProjectMembersForProjectID(ctx context.Context, projectID uuid.UUID) ([]ProjectMember, error) {
	rows, err := q.db.QueryContext(ctx, getProjectMembersForProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectMember
	for rows.Next() {
		var i ProjectMember
		if err := rows.Scan(
			&i.ProjectMemberID,
			&i.ProjectID,
			&i.UserID,
			&i.AddedAt,
			&i.RoleCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRolesForUserID = `-- name: GetProjectRolesForUserID :many
SELECT project_id, role_code FROM project_member WHERE user_id = $1
`

type GetProjectRolesForUserIDRow struct {
	ProjectID uuid.UUID `json:"project_id"`
	RoleCode  string    `json:"role_code"`
}

func (q *Queries) GetProjectRolesForUserID(ctx context.Context, userID uuid.UUID) ([]GetProjectRolesForUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectRolesForUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectRolesForUserIDRow
	for rows.Next() {
		var i GetProjectRolesForUserIDRow
		if err := rows.Scan(&i.ProjectID, &i.RoleCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicOn = `-- name: GetPublicOn :one
SELECT public_on FROM project WHERE project_id = $1
`

func (q *Queries) GetPublicOn(ctx context.Context, projectID uuid.UUID) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, getPublicOn, projectID)
	var public_on sql.NullTime
	err := row.Scan(&public_on)
	return public_on, err
}

const getRoleForProjectMemberByUserID = `-- name: GetRoleForProjectMemberByUserID :one
SELECT code, role.name FROM project_member INNER JOIN role ON role.code = project_member.role_code
WHERE user_id = $1 AND project_id = $2
`

type GetRoleForProjectMemberByUserIDParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) GetRoleForProjectMemberByUserID(ctx context.Context, arg GetRoleForProjectMemberByUserIDParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleForProjectMemberByUserID, arg.UserID, arg.ProjectID)
	var i Role
	err := row.Scan(&i.Code, &i.Name)
	return i, err
}

const getUserRolesForProject = `-- name: GetUserRolesForProject :one
SELECT p.team_id, COALESCE(tm.role_code, '') AS team_role, COALESCE(pm.role_code, '') AS project_role
  FROM project AS p
  LEFT JOIN project_member AS pm ON pm.project_id = p.project_id AND pm.user_id = $1
  LEFT JOIN team_member AS tm ON tm.team_id = p.team_id AND tm.user_id = $1
  WHERE p.project_id = $2
`

type GetUserRolesForProjectParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProjectID uuid.UUID `json:"project_id"`
}

type GetUserRolesForProjectRow struct {
	TeamID      uuid.UUID `json:"team_id"`
	TeamRole    string    `json:"team_role"`
	ProjectRole string    `json:"project_role"`
}

func (q *Queries) GetUserRolesForProject(ctx context.Context, arg GetUserRolesForProjectParams) (GetUserRolesForProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getUserRolesForProject, arg.UserID, arg.ProjectID)
	var i GetUserRolesForProjectRow
	err := row.Scan(&i.TeamID, &i.TeamRole, &i.ProjectRole)
	return i, err
}

const setPublicOn = `-- name: SetPublicOn :one
UPDATE project SET public_on = $2 WHERE project_id = $1 RETURNING project_id, team_id, created_at, name, public_on, short_id
`

type SetPublicOnParams struct {
	ProjectID uuid.UUID    `json:"project_id"`
	PublicOn  sql.NullTime `json:"public_on"`
}

func (q *Queries) SetPublicOn(ctx context.Context, arg SetPublicOnParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, setPublicOn, arg.ProjectID, arg.PublicOn)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.PublicOn,
		&i.ShortID,
	)
	return i, err
}

const updateProjectMemberRole = `-- name: UpdateProjectMemberRole :one
UPDATE project_member SET role_code = $3 WHERE project_id = $1 AND user_id = $2
  RETURNING project_member_id, project_id, user_id, added_at, role_code
`

type UpdateProjectMemberRoleParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	UserID    uuid.UUID `json:"user_id"`
	RoleCode  string    `json:"role_code"`
}

func (q *Queries) UpdateProjectMemberRole(ctx context.Context, arg UpdateProjectMemberRoleParams) (ProjectMember, error) {
	row := q.db.QueryRowContext(ctx, updateProjectMemberRole, arg.ProjectID, arg.UserID, arg.RoleCode)
	var i ProjectMember
	err := row.Scan(
		&i.ProjectMemberID,
		&i.ProjectID,
		&i.UserID,
		&i.AddedAt,
		&i.RoleCode,
	)
	return i, err
}

const updateProjectNameByID = `-- name: UpdateProjectNameByID :one
UPDATE project SET name = $2 WHERE project_id = $1 RETURNING project_id, team_id, created_at, name, public_on, short_id
`

type UpdateProjectNameByIDParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Name      string    `json:"name"`
}

func (q *Queries) UpdateProjectNameByID(ctx context.Context, arg UpdateProjectNameByIDParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectNameByID, arg.ProjectID, arg.Name)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.PublicOn,
		&i.ShortID,
	)
	return i, err
}
