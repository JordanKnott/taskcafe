// Code generated by sqlc. DO NOT EDIT.
// source: team.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createTeam = `-- name: CreateTeam :one
INSERT INTO team (organization_id, created_at, name, owner) VALUES ($1, $2, $3, $4) RETURNING team_id, created_at, name, organization_id, owner
`

type CreateTeamParams struct {
	OrganizationID uuid.UUID `json:"organization_id"`
	CreatedAt      time.Time `json:"created_at"`
	Name           string    `json:"name"`
	Owner          uuid.UUID `json:"owner"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, createTeam,
		arg.OrganizationID,
		arg.CreatedAt,
		arg.Name,
		arg.Owner,
	)
	var i Team
	err := row.Scan(
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.OrganizationID,
		&i.Owner,
	)
	return i, err
}

const deleteTeamByID = `-- name: DeleteTeamByID :exec
DELETE FROM team WHERE team_id = $1
`

func (q *Queries) DeleteTeamByID(ctx context.Context, teamID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTeamByID, teamID)
	return err
}

const getAllTeams = `-- name: GetAllTeams :many
SELECT team_id, created_at, name, organization_id, owner FROM team
`

func (q *Queries) GetAllTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, getAllTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.OrganizationID,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberTeamIDsForUserID = `-- name: GetMemberTeamIDsForUserID :many
SELECT team_id FROM team_member WHERE user_id = $1
`

func (q *Queries) GetMemberTeamIDsForUserID(ctx context.Context, userID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getMemberTeamIDsForUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var team_id uuid.UUID
		if err := rows.Scan(&team_id); err != nil {
			return nil, err
		}
		items = append(items, team_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnedTeamsForUserID = `-- name: GetOwnedTeamsForUserID :many
SELECT team_id, created_at, name, organization_id, owner FROM team WHERE owner = $1
`

func (q *Queries) GetOwnedTeamsForUserID(ctx context.Context, owner uuid.UUID) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, getOwnedTeamsForUserID, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.OrganizationID,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT team_id, created_at, name, organization_id, owner FROM team WHERE team_id = $1
`

func (q *Queries) GetTeamByID(ctx context.Context, teamID uuid.UUID) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeamByID, teamID)
	var i Team
	err := row.Scan(
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.OrganizationID,
		&i.Owner,
	)
	return i, err
}

const getTeamsForOrganization = `-- name: GetTeamsForOrganization :many
SELECT team_id, created_at, name, organization_id, owner FROM team WHERE organization_id = $1
`

func (q *Queries) GetTeamsForOrganization(ctx context.Context, organizationID uuid.UUID) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, getTeamsForOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.OrganizationID,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTeamOwner = `-- name: SetTeamOwner :one
UPDATE team SET owner = $2 WHERE team_id = $1 RETURNING team_id, created_at, name, organization_id, owner
`

type SetTeamOwnerParams struct {
	TeamID uuid.UUID `json:"team_id"`
	Owner  uuid.UUID `json:"owner"`
}

func (q *Queries) SetTeamOwner(ctx context.Context, arg SetTeamOwnerParams) (Team, error) {
	row := q.db.QueryRowContext(ctx, setTeamOwner, arg.TeamID, arg.Owner)
	var i Team
	err := row.Scan(
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.OrganizationID,
		&i.Owner,
	)
	return i, err
}

const updateTeamOwnerByOwnerID = `-- name: UpdateTeamOwnerByOwnerID :many
UPDATE team SET owner = $2 WHERE owner = $1 RETURNING team_id
`

type UpdateTeamOwnerByOwnerIDParams struct {
	Owner   uuid.UUID `json:"owner"`
	Owner_2 uuid.UUID `json:"owner_2"`
}

func (q *Queries) UpdateTeamOwnerByOwnerID(ctx context.Context, arg UpdateTeamOwnerByOwnerIDParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, updateTeamOwnerByOwnerID, arg.Owner, arg.Owner_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var team_id uuid.UUID
		if err := rows.Scan(&team_id); err != nil {
			return nil, err
		}
		items = append(items, team_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
